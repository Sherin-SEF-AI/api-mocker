# Mock API Response Management System

## Overview

The Mock API Response Management System provides comprehensive functionality for creating and managing mock API responses with support for pytest integration, automated testing, and efficient response management.

## Core Components

### MockAPIResponse Class

The `MockAPIResponse` class is the core component for defining mock API responses. It supports various response types, conditional logic, and dynamic content generation.

#### Basic Usage

```python
from api_mocker.mock_responses import MockAPIResponse, HTTPMethod, ResponseType

# Create a simple static response
response = MockAPIResponse(
    path="/api/users",
    method=HTTPMethod.GET,
    status_code=200,
    body={"users": [{"id": 1, "name": "John Doe"}]}
)
```

#### Response Types

The system supports several response types:

1. **Static Responses**: Fixed content that doesn't change
2. **Dynamic Responses**: Content generated by custom functions
3. **Templated Responses**: Content with variable substitution
4. **Conditional Responses**: Content based on request conditions
5. **Delayed Responses**: Responses with artificial delays
6. **Error Responses**: Simulated error conditions

#### Path Matching

The system supports multiple path matching strategies:

```python
# Exact path matching
response = MockAPIResponse(path="/api/users/123")

# Wildcard matching
response = MockAPIResponse(path="/api/users/*")

# Parameter matching
response = MockAPIResponse(path="/api/users/{user_id}")
```

#### Conditional Logic

Define conditions for when a response should be used:

```python
response = MockAPIResponse(
    path="/api/users",
    method=HTTPMethod.POST,
    conditions=[
        {
            "type": "header",
            "name": "Authorization",
            "value": "Bearer admin_token"
        },
        {
            "type": "body",
            "field": "user.role",
            "value": "admin"
        }
    ],
    body={"message": "Admin user created"}
)
```

#### Template Variables

Use template variables for dynamic content:

```python
response = MockAPIResponse(
    path="/api/users/{user_id}",
    response_type=ResponseType.TEMPLATED,
    template_vars={
        "user_id": "123",
        "name": "John Doe",
        "email": "john@example.com"
    },
    body={
        "id": "{{user_id}}",
        "name": "{{name}}",
        "email": "{{email}}",
        "created_at": "2023-01-01T00:00:00Z"
    }
)
```

#### Dynamic Response Generation

Use custom functions to generate responses:

```python
def generate_user_response(context):
    return {
        "id": context.get("user_id", "default"),
        "name": context.get("name", "Default User"),
        "timestamp": time.time(),
        "random_data": f"data_{random.randint(1000, 9999)}"
    }

response = MockAPIResponse(
    path="/api/users",
    response_type=ResponseType.DYNAMIC,
    generator_func=generate_user_response
)
```

### MockSet Class

The `MockSet` class provides efficient management of multiple mock responses with fast lookup and filtering capabilities.

#### Basic Usage

```python
from api_mocker.mock_responses import MockSet

# Create a mock set
mock_set = MockSet("my_api_mocks")

# Add responses
user_response = MockAPIResponse(path="/api/users", name="get_users")
post_response = MockAPIResponse(path="/api/posts", name="get_posts")

mock_set.add_response(user_response)
mock_set.add_response(post_response)
```

#### Finding Matching Responses

```python
# Find the best matching response for a request
matching_response = mock_set.find_matching_response(
    path="/api/users/123",
    method="GET",
    headers={"Authorization": "Bearer token"},
    body={"user_id": "123"}
)
```

#### Filtering Responses

```python
# Filter by status code
success_responses = mock_set.filter(status_code=200)

# Filter by tags
user_responses = mock_set.filter(tags="users")

# Filter by multiple criteria
api_responses = mock_set.filter(tags=["api", "users"], status_code=200)
```

#### Indexing and Lookup

```python
# Get responses by path
path_responses = mock_set.get_by_path("/api/users")

# Get responses by HTTP method
get_responses = mock_set.get_by_method("GET")

# Get responses by tag
tagged_responses = mock_set.get_by_tag("users")

# Get response by name
named_response = mock_set.get_by_name("get_users")
```

## Example Subclasses

The system includes pre-built subclasses for common API interactions:

### CommitResponse

```python
from api_mocker.mock_responses import CommitResponse

# Create a Git commit response
commit_response = CommitResponse(
    template_vars={
        "sha": "abc123def456",
        "message": "feat: add new feature",
        "author": "John Doe"
    }
)
```

### ForkResponse

```python
from api_mocker.mock_responses import ForkResponse

# Create a repository fork response
fork_response = ForkResponse()
```

### PushResponse

```python
from api_mocker.mock_responses import PushResponse

# Create a Git push response
push_response = PushResponse(
    template_vars={
        "ref": "refs/heads/main",
        "sha": "def456ghi789"
    }
)
```

### ForcePushResponse

```python
from api_mocker.mock_responses import ForcePushResponse

# Create a force push response
force_push_response = ForcePushResponse()
```

## Convenience Functions

The system provides convenience functions for common operations:

### create_user_response

```python
from api_mocker.mock_responses import create_user_response

# Create a user response with custom data
user_response = create_user_response("123", "John Doe")
```

### create_error_response

```python
from api_mocker.mock_responses import create_error_response

# Create an error response
error_response = create_error_response(404, "User not found")
```

### create_delayed_response

```python
from api_mocker.mock_responses import create_delayed_response

# Create a response with delay
delayed_response = create_delayed_response(1000)  # 1 second delay
```

## Pytest Integration

The system includes a pytest fixture for easy integration:

```python
import pytest
from api_mocker.mock_responses import setup_api_mocks

def test_user_api(setup_api_mocks):
    mock_set = setup_api_mocks
    
    # Add mock responses
    user_response = create_user_response("123", "John Doe")
    mock_set.add_response(user_response)
    
    # Test finding responses
    matching = mock_set.find_matching_response("/users/123", "GET")
    assert matching is not None
    assert matching.name == "GET_users_123"
    
    # Test response generation
    result = matching.generate_response()
    assert result["status_code"] == 200
    assert result["body"]["id"] == "123"
```

## Advanced Usage Scenarios

### Complex Conditional Matching

```python
response = MockAPIResponse(
    path="/api/admin/users",
    method=HTTPMethod.POST,
    conditions=[
        {
            "type": "header",
            "name": "Authorization",
            "value": "Bearer admin_token"
        },
        {
            "type": "body",
            "field": "user.role",
            "value": "admin"
        },
        {
            "type": "custom",
            "function": lambda headers, body: "admin" in headers.get("X-User-Role", "")
        }
    ],
    body={"message": "Admin user created successfully"}
)
```

### Priority-Based Response Selection

```python
mock_set = MockSet("priority_test")

# Add responses with different priorities
general_response = MockAPIResponse(
    path="/api/users/*",
    priority=1,
    name="general",
    body={"message": "General response"}
)

specific_response = MockAPIResponse(
    path="/api/users/123",
    priority=10,
    name="specific",
    body={"message": "Specific response"}
)

mock_set.add_response(general_response)
mock_set.add_response(specific_response)

# Higher priority response will be selected for exact matches
matching = mock_set.find_matching_response("/api/users/123", "GET")
assert matching.name == "specific"
```

### Error Probability Simulation

```python
response = MockAPIResponse(
    path="/api/unreliable",
    error_probability=0.3,  # 30% chance of error
    body={"data": "success"}
)

# Test multiple times to see error simulation
for _ in range(10):
    result = response.generate_response()
    print(f"Status: {result['status_code']}")
```

## File Operations

### Saving and Loading Mock Sets

```python
# Save mock set to file
mock_set = MockSet("my_mocks")
mock_set.add_response(create_user_response("123", "John Doe"))
mock_set.save_to_file("my_mocks.yaml")

# Load mock set from file
loaded_mock_set = MockSet.load_from_file("my_mocks.yaml")
```

### Serialization

```python
# Convert to dictionary
mock_set_dict = mock_set.to_dict()

# Convert back to mock set
restored_mock_set = MockSet.from_dict(mock_set_dict)
```

## Performance Considerations

### Indexing

The `MockSet` class automatically builds indexes for fast lookup:

- **Path Index**: O(1) lookup by path
- **Method Index**: O(1) lookup by HTTP method
- **Tag Index**: O(1) lookup by tag
- **Name Index**: O(1) lookup by response name

### Memory Usage

- Each response object uses approximately 1-2KB of memory
- Indexes add minimal overhead (~100 bytes per response)
- Large mock sets (>1000 responses) are efficiently managed

### Response Generation

- Static responses: O(1) generation time
- Templated responses: O(n) where n is template variable count
- Dynamic responses: Depends on generator function complexity
- Conditional evaluation: O(m) where m is condition count

## Best Practices

### 1. Response Naming

Use descriptive names for your responses:

```python
# Good
response = MockAPIResponse(
    path="/api/users",
    name="get_users_list",
    body={"users": []}
)

# Avoid
response = MockAPIResponse(
    path="/api/users",
    name="response1",
    body={"users": []}
)
```

### 2. Tagging

Use tags to organize and filter responses:

```python
response = MockAPIResponse(
    path="/api/users",
    tags=["users", "api", "v1"],
    body={"users": []}
)
```

### 3. Priority Management

Use priorities to handle overlapping paths:

```python
# General response (low priority)
general = MockAPIResponse(
    path="/api/users/*",
    priority=1,
    body={"message": "General response"}
)

# Specific response (high priority)
specific = MockAPIResponse(
    path="/api/users/123",
    priority=10,
    body={"message": "Specific response"}
)
```

### 4. Error Handling

Include error responses in your mock sets:

```python
# Success response
success_response = MockAPIResponse(
    path="/api/users",
    status_code=200,
    body={"users": []}
)

# Error response
error_response = MockAPIResponse(
    path="/api/users",
    status_code=500,
    body={"error": "Internal server error"}
)

mock_set.add_response(success_response)
mock_set.add_response(error_response)
```

### 5. Testing

Always test your mock responses:

```python
def test_mock_response():
    response = create_user_response("123", "John Doe")
    
    # Test matching
    assert response.matches_request("/users/123", "GET")
    assert not response.matches_request("/users/456", "GET")
    
    # Test generation
    result = response.generate_response()
    assert result["status_code"] == 200
    assert result["body"]["id"] == "123"
```

## Integration with Existing Systems

### FastAPI Integration

```python
from fastapi import FastAPI, Request
from api_mocker.mock_responses import MockSet

app = FastAPI()
mock_set = MockSet("api_mocks")

@app.middleware("http")
async def mock_middleware(request: Request, call_next):
    # Check if we have a mock response
    mock_response = mock_set.find_matching_response(
        path=request.url.path,
        method=request.method,
        headers=dict(request.headers),
        body=await request.body()
    )
    
    if mock_response:
        result = mock_response.generate_response()
        return JSONResponse(
            status_code=result["status_code"],
            content=result["body"],
            headers=result["headers"]
        )
    
    return await call_next(request)
```

### Flask Integration

```python
from flask import Flask, request, jsonify
from api_mocker.mock_responses import MockSet

app = Flask(__name__)
mock_set = MockSet("api_mocks")

@app.before_request
def mock_request():
    mock_response = mock_set.find_matching_response(
        path=request.path,
        method=request.method,
        headers=dict(request.headers),
        body=request.get_json()
    )
    
    if mock_response:
        result = mock_response.generate_response()
        return jsonify(result["body"]), result["status_code"], result["headers"]
```

## Troubleshooting

### Common Issues

1. **Response Not Found**
   - Check path matching patterns
   - Verify HTTP method
   - Ensure conditions are met

2. **Template Variables Not Substituted**
   - Check variable names in template
   - Verify template_vars dictionary
   - Ensure response_type is TEMPLATED

3. **Performance Issues**
   - Use appropriate indexes
   - Limit condition complexity
   - Consider response caching

4. **Memory Usage**
   - Remove unused responses
   - Use lazy loading for large sets
   - Monitor response count

### Debug Mode

Enable debug mode for detailed logging:

```python
import logging

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("api_mocker.mock_responses")

# Debug information will be logged
mock_set = MockSet("debug_mocks")
```

## Contributing

When contributing to the mock response system:

1. Follow the existing code style
2. Add comprehensive tests
3. Update documentation
4. Include type hints
5. Add docstrings for new functions

## License

This mock response system is part of the API-Mocker project and is licensed under the MIT License. 